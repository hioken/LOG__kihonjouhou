
〇2分探索の回数
O(log2n)
これは
2^"平均比較回数" ≦ N ＜ 2^"最大比較回数"
ってこと


## ハッシュ関数
〇オープンアドレス法
1. 配列の空きには-1等、空きを意味するデータを入れておく
2. 入力時にシノニムがあった場合、その位置+1等の場所に入れておく
3. 検索した格納場所が、対象と違っていた場合、そのアドレス+1のデータを読み込む、これを-1が見つかるまで繰り返す
・必要な変数
- カウント変数
- flg = 見つかるor空きに衝突(存在しない事が確定)の時に、それぞれの値を入れる(見つかったら正、空きだったら負の数)
- ストッパー = カウント変数がストッパー
・注意点
- 削除時に


〇 チェイン法
 - シノニム用の領域を用意して、ハッシュ関数をそっちにリスト方式で繋ぐ


〇 オーダー
線形探索法の場合

- コード
```
#include <stdio.h>

int data[N];
int search, i;

int main(void) {
  scanf("%d", &search); // 処理1 入力

  while (i < N) { // 処理2 ループの判定
    if (data[i] == search) { // 処理3 比較
      printf("Find!!"); // 処理6-1 見つかった報告
      return 0;
    }
    i++; // 処理4 カウント変数の処理
    /* (whileに戻る) */ // 処理5 whileに戻る
  }
  printf("Not Finded..."); // 処理6-2 見つからなかった報告
  return 0;
}
```

- 最大回数
処理1がNによらず1回、処理2はN回 + 1回、処理3 ~ 5がNの回数、処理6が1回、よって
1 + (N + 1) + N + N + N + 1 = 4N + 3
この4N + 3というのが、このアルゴリズムの詳細な性能になる

- オーダー記法
  - 細かい係数は処理にさほど影響しないので、一番影響のある部分のみを残したのが、オーダー記法
4N + 3 = O(n) となる
  - log
  xの何乗かを求める式をlogで表す
  logx
  ２分探索の場合
  O(log2n)


〇オーダー記法簡易理解
O(n) : for{}
O(n^2) : for{for{}}


- O(1)
  - ハッシュ
  - 配列へのアクセス

- O(log n) / O(log2 n)
  - 二分探索

- O(n)
  - for文
  - 線形探索

- O(n log n)
  - ソート系
    - クイックソート
    - マージソート

- O(n^2)
  - for{for{}}
  - 挿入ソート
  - 処理を工夫しないとこれになってしまう
